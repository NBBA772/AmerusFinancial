{
  "resolvedId": "/Users/amerusfinancial/Desktop/projects/Amerus/app/node_modules/prosemirror-gapcursor/dist/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n",
      "start": 1761251039926,
      "end": 1761251040443,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1761251040443,
      "end": 1761251040443,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1761251040443,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1761251040445,
      "end": 1761251040445,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1761251040445,
      "end": 1761251040446,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "unhead:use-seo-meta-transform",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1761251040446,
      "end": 1761251040446,
      "order": "normal"
    }
  ]
}
